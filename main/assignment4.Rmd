---
title: "Untitled"
author: "DingYuchen"
date: '`r Sys.Date()`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

# set parameters

```{r}
# set the seed
set.seed(1)
# number of products
J <- 10
# dimension of product characteristics including the intercept
K <- 3
# number of markets
T <- 100
# number of consumers per market
N <- 500
# number of Monte Carlo
L <- 500
# set parameters of interests
beta <- rnorm(K); 
beta[1] <- 4
beta
sigma <- abs(rnorm(K)); sigma
mu <- 0.5
omega <- 1
# set auxiliary parameters
price_xi <- 1
sd_x <- 2
sd_xi <- 0.5
sd_c <- 0.05
sd_p <- 0.05
```

# simulate data

```{r}
X <- data.frame(j = 0:J,
                x_1 = c(0, rep(1, J)),
                x_2 = c(0, rnorm(J, 0, sd_x)),
                x_3 = c(0, rnorm(J, 0, sd_x)))
xi <- rnorm(T*J, 0, sd_xi)
c <- rlnorm(T*J, 0, sd_c)
p <- c + rlnorm(T*J, price_xi*xi, sd_p)
M <- data.frame(j = rep(1:J, T), 
                t = rep(1:T, each=J), 
                xi, c, p)
```

# transform product data

```{r}
library(magrittr)
# sample product
Jt <- NA
MM <- data.frame()
for (i in 1:T) {
  Jt[i] <- sample(1:J,1)
M_n <- filter(M,t==i) %>% 
  slice_sample(n=Jt[i])
MM <- rbind(MM,M_n)
}
MM <- arrange(MM,t,j)
# add outside options
OO <- data.frame(j = rep(0,T), 
                 t = 1:T, 
                 xi = rep(0,T), 
                 c= rep(0,T),
                 p= rep(0,T)) 
M <- rbind(MM,OO) %>% 
  arrange(t,j)
remove(MM,OO,M_n)
```

# simulate consumer hererogenity

```{r}
V <- data.frame(i = rep(1:N,T),
                t = rep(1:T, each=N),
                v_x_1 = rnorm(T*N),
                v_x_2 = rnorm(T*N), 
                v_x_3 = rnorm(T*N), 
                v_p = rnorm(T*N))
df <- M %>% 
  dplyr::left_join(X, by="j") %>% 
  dplyr::left_join(V, by="t") %>% 
  dplyr::arrange(t, i, j)
e <- evd::rgumbel(nrow(df))
head(e)
head(df)
```

# compute choice and share

```{r compute}
u <- Economics::compute_indirect_utility(df, beta, sigma, mu, omega)
head(u)
df_choice_smooth <- Economics::compute_choice_smooth(X, M, V, beta, sigma, mu, omega)
summary(df_choice_smooth)
df_share_smooth <- Economics::compute_share_smooth(X, M, V, beta, sigma, mu, omega)
summary(df_share_smooth)
```

# do MC simulation

```{r}
# Monte-Carlo Simulation
V_mcmc <- data.frame(i = rep(1:N,T), t = rep(1:T, each=N), v_x_1 = rnorm(T*N),
                v_x_2 = rnorm(T*N), v_x_3 = rnorm(T*N), v_p = rnorm(T*N))
e_mcmc <- evd::rgumbel(nrow(df))
head(V_mcmc)
head(e_mcmc)
theta <- c(beta, sigma, mu, omega)
```

# use method in assignment3

```{r}
# solve theta without fixed effect
M_no <- M %>% dplyr::mutate(xi = 0)
optim_list <- optim(par = theta, fn = Economics::NLLS_objective_A3, 
                    df_share = df_share_smooth, X = X, M = M_no, 
                    V_mcmc = V_mcmc, e_mcmc = e_mcmc, method = "Nelder-Mead")
```

# compute delta, then utility, choice and share

```{r compute delta}
# compute delta
delta <- left_join(M, X, by ="j") %>% 
  mutate(delta = beta[1]*x_1 + beta[2]*x_2 + beta[3]*x_3 -
           exp(mu+omega^2/2)*p + xi) %>%
  select(t,j,delta)
head(delta)
# compute utility
u_delta <- Economics::compute_indirect_utility_delta(df, delta, sigma, mu, omega)
head(u_delta)
summary(u - u_delta)
# compute choice
df_choice_smooth_delta <- Economics::compute_choice_smooth_delta(X,M,V,delta,sigma,mu,omega)
summary(df_choice_smooth_delta)
summary(df_choice_smooth$q - df_choice_smooth_delta$q)
# compute share
df_share_smooth_delta <-
  Economics::compute_share_smooth_delta(X,M,V,delta,sigma,mu,omega)
summary(df_share_smooth_delta)
summary(df_share_smooth$s - df_share_smooth_delta$s)
```

# solve delta

```{r}
kappa <- 1
lamda <- 1e-3
delta_new <- Economics::solve_delta(df_share_smooth, X, M, V, delta, sigma,
                         mu, omega, kappa,lamda)
head(delta_new)
summary(delta_new$delta - delta$delta)
```

# solve delta with MC shock

```{r}
delta_new <- Economics::solve_delta(df_share_smooth, X, M, V_mcmc, delta, sigma,
                         mu, omega, kappa,lamda)
summary(delta_new$delta - delta$delta)
```

# solve linear parameters and fixed effect

```{r}
# solve beta
Psi <- diag(length(beta) + 1)
theta_linear <-
  Economics::compute_theta_linear(df_share_smooth, delta, mu, omega, Psi) 
cbind(theta_linear, beta)
# solve xi
xi_new <- Economics::solve_xi(df_share_smooth, delta, beta, mu, omega)
head(xi_new)
xi_true <-
  df_share_smooth %>%
  dplyr::filter(j != 0) %>%
  dplyr::select(xi)
summary(xi_true - xi_new)
```

# compute GMM

```{r}
# set parameters
theta_nonlinear <- c(mu, omega, sigma)
# compute GMM objective function
objective <- 
  Economics::GMM_objective_A4(theta_nonlinear, delta, df_share_smooth, Psi, X, M, V_mcmc, kappa, lamda)
objective
```

# plot GMM objective function

```{r GMM plot}
# plot GMM objective function
tm <- seq(0,2,by=0.2)
library(latex2exp)
x_labs <- c(latex2exp::TeX("$\\mu$"), 
            latex2exp::TeX("$\\omega$"), 
            latex2exp::TeX("$\\sigma_1$"), 
            latex2exp::TeX("$\\sigma_2$"), 
            latex2exp::TeX("$\\sigma_3$"))
library(foreach)
doParallel::registerDoParallel()
foreach(i = 1:length(theta_nonlinear), 
        .packages = c("dplyr","ggplot2")
        ) %dopar% {
 objective_fn <- rep(0,length(tm))
 theta_nonlinear_search <- theta_nonlinear
 for (j in 1:length(tm)) {
   theta_nonlinear_search[i] <- 
     theta_nonlinear[i]*tm[j]
   objective_fn[j] <- 
     Economics::GMM_objective_A4(theta_nonlinear_search, delta, 
                                 df_share_smooth, Psi, X, M, V, kappa, lamda)
 }
 df_object <- data.frame(x = theta_nonlinear[i]*tm,
                         y = objective_fn)
ggplot(df_object, aes(x,y))+
  geom_point()+
  coord_cartesian()+
  labs(x = x_labs[i] , y = "objective function")
}
```

# minimize GMM objective function

```{r}
GMM <- function(theta_nl){
  Economics::GMM_objective_A4(theta_nl, delta, df_share_smooth, 
                              Psi, X, M, V_mcmc, kappa, lamda)
}
estimate <- optim(
                  par = theta_nonlinear, 
                  fn = GMM,
                  )
cbind(theta_nonlinear, estimate$par)
```


